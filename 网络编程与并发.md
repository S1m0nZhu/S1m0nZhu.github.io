---
title: 网络编程与并发
date: 2019-08-23 17:56:54
tags: socket-programming       
concurrency
---

1、简述OSI七层协议
a) 四层协议：应用层、传输层、网络层、网络接口层
b) 五层协议：
应用层：用户使用的应用程序都归属于应用层，作用为规定应用程序的数据格式。
传输层：网络层帮我们找到主机，但是区分应用层的应用就是靠端口，所以传输层就是建立端口到端口的通信。（端口范围0-65535，0-1023为系统占用端口）
网络层：区分不同的广播域或者子网（否则发送一条数据全世界都会受到，是灾难）。
数据链路层：定义电信号的分组方式。
物理层：基于电器特性发送高低点电压（电信号），高电压对应数字1，低电压对应数字0。
c）七层协议：（应用层、表示层、会话层）、传输层、网络层、（数据链路层、物理层）
2、简述三次握手、四次挥手的流程
1 三次握手
客户端通过向服务器端发送一个SYN来创建一个主动打开，作为三次握手的一部分。客户端把这段连接的序号设定为随机数 A。
服务器端应当为一个合法的SYN回送一个SYN/ACK。ACK 的确认码应为 A+1，SYN/ACK 包本身又有一个随机序号 B。
最后，客户端再发送一个ACK。当服务端受到这个ACK的时候，就完成了三路握手，并进入了连接创建状态。此时包序号被设定为收到的确认号 A+1，而响应则为 B+1。
2 四次挥手
注意: 中断连接端可以是客户端，也可以是服务器端. 下面仅以客户端断开连接举例, 反之亦然.
客户端发送一个数据分段, 其中的 FIN 标记设置为1. 客户端进入 FIN-WAIT 状态. 该状态下客户端只接收数据, 不再发送数据.
服务器接收到带有 FIN = 1 的数据分段, 发送带有 ACK = 1 的剩余数据分段, 确认收到客户端发来的 FIN 信息.
服务器等到所有数据传输结束, 向客户端发送一个带有 FIN = 1 的数据分段, 并进入 CLOSE-WAIT 状态, 等待客户端发来带有 ACK = 1 的确认报文.
客户端收到服务器发来带有 FIN = 1 的报文, 返回 ACK = 1 的报文确认, 为了防止服务器端未收到需要重发, 进入 TIME-WAIT 状态. 服务器接收到报文后关闭连接. 客户端等待 2MSL 后未收到回复, 则认为服务器成功关闭, 客户端关闭连接.
图解: http://blog.csdn.net/whuslei/article/details/6667471
3、什么是ARP协议
ARP协议，全称“Address Resolution Protocol”,中文名是地址解析协议，使用ARP协议可实现通过IP地址获得对应主机的物理地址（MAC地址）。
https://www.cnblogs.com/luchuangao/articles/6053742.html
4、TCP和UDP的区别
TCP
收发两端（客户端和服务器端）都要有成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法(Nagle算法)，将多次间隔较小、数据量小的数据，合并成一个大的数据块，然后进行封包。这样接收端就难于分辨，必须提供拆包机制。
如果利用TCP每次发送数据，就与对方建立连接，然后双方发送完一段数据后，就关闭连接，这样就不会出现粘包问题(因为只有一种包结构,类似于http协议)。关闭连接主要要双方都发送close连接。
如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储即可，也不用考虑粘包
如果双方建立连接，需要在连接后一段时间内发送不同结构数据，就需要考虑粘包问题。所以一般可能会在头加一个数据长度之类的包，以确保接收。
UDP
对于UDP，不会使用块的合并优化算法。实际上目前认为，是由于UDP支持的是一对多的模式(注意区分不是并发模式)，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中有消息头（消息来源地址，端口等信息），这样对于接收端来说，就容易进行区分处理了，所以UDP不会出现粘包问题。
5、什么是局域网和广域网
一、局域网
局域网（Local Area Network），简称LAN，是指在某一区域内由多台计算机互联成的计算机组。“某一区域”指的是同一办公室、同一建筑物、同一公司和同一学校等，一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、扫描仪共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。
二、广域网
广域网（Wide Area Network），简称WAN，是一种跨越大的、地域性的计算机网络的集合。通常跨越省、市，甚至一个国家。广域网包括大大小小不同的子网，子网可以是局域网，也可以是小型的广域网。
三、局域网和广域网的区别
局域网是在某一区域内的，而广域网要跨越较大的地域，那么如何来界定这个区域呢？例如，一家大型公司的总公司位于北京，而分公司遍布全国各地，如果该公司将所有的分公司都通过网络联接在一起，那么一个分公司就是一个局域网，而整个总公司网络就是一个广域网。
6、为何基于TCP协议的通信要比基于UDP协议的通信更可靠
tcp:可靠 对方给了确认收到信息，才发下一个，如果没收到确认信息就重发
udp:不可靠 一直发数据，不需要对方回应
7、什么是socket，简述基于TCP协议的套接字通信的流程
Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部。
服务端：创建socket对象，绑定ip端口bind(),  设置最大链接数listen(),  accept()与客户端的connect()创建双向管道， send(), recv(),close()
客户端：创建socket对象，connect()与服务端accept()创建双向管道 ,  send(), recv(),close()
8、什么是粘包问题，socket中造成粘包的原因是什么
粘包：数据粘在一起，主要因为：接收方不知道消息之间的界限，不知道一次性提取多少字节的数据造成的
数据量比较小，时间间隔比较短，就合并成了一个包，这是底层的一个优化算法（Nagle算法）
9、IO多路复用的作用
I/O multiplexing就是所谓的select，poll，epoll，也称这种I/O方式为事件驱动I/O(event driven I/O)。
select/epoll的好处就在于单个进程就可以同时处理多个网络连接的I/O。  它的基本原理就是select/poll/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。
I/O 多路复用的特点是通过一种机制使一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。
多道技术的实现就是为了解决多个程序竞争或者共享同一个资源（比如cpu）的有序调度问题，解决方式即是多路复用。多路复用分为时间上的复用和空间上的复用，空间上的多路复用是指将内存分为几部分，每一部分放一个程序，这样同一时间内存中就有多道程序，前提保证内存是分割；时间上的多路复用是指多个程序需要在一个cpu上运行，不同的程序轮流使用cpu，当某个程序运行的时间过长或者遇到I/O阻塞，操作系统会把cpu分配给下一个程序，保证cpu处于高使用率，实现伪并发。
10、什么是防火墙及作用
http://www.cnblogs.com/loneywang/archive/2007/09/30/912029.html
11、select、poll、epoll模型的区别
https://www.cnblogs.com/Anker/p/3265058.html
12、简述进程、线程、协程的区别以及应用场景
什么是进程
进程（有时称为重量级进程）是一个执行中的程序。每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据。同一个程序执行两次，属于是两个不同进程。
什么是线程
线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有就绪、阻塞和运行三种基本状态。
就绪状态是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机； 运行状态是指线程占有处理机正在运行；
阻塞状态是指线程在等待一个事件（如某个信号量），逻辑上不可执行。
什么是协程
协程是“微线程”，并非实际存在；是由程序员人为创造出来并控制程序：先执行某段代码、再跳到某处执行某段代码。
如果遇到非IO请求来回切换：性能更低。
如果遇到IO（耗时）请求来回切换：性能高、实现并发（本质上利用IO等待的过程，再去干一些其他的事）
进程池与线程池
基于多进程或多线程实现并发的套接字通信，然而这种方式的缺陷是：服务的开启的进程数或线程数都会随着并发的客户端数目地增多而增多，这对服务端主机带来巨大的压力，于是必须对服务端开启的进程数或线程数加以控制，让机器在一个自己可以承受的范围内运行，这就是进程池或线程池的用途，例如进程池，就是用来存放进程的池子，本质还是基于多进程，只不过是对开启进程的数目加上了限制。
1、进程和线程的区别？
答：进程拥有一个完整的虚拟地址空间，不依赖于线程而独立存在；反之，线程是进程的一部分，没有自己的地址空间，与进程内的其他线程一起共享分配给该进程的所有资源。
比如：开个QQ，开了一个进程；开了迅雷，开了一个进程。在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。所以运行某个软件，相当于开了一个进程。在这个软件运行的过程里（在这个进程里），多个工作支撑的完成QQ的运行，那么这“多个工作”分别有一个线程。所以一个进程管着多个线程。通俗的讲：“进程是爹妈，管着众多的线程儿子”。
参考自：https://www.zhihu.com/question/25532384
2、为什么说python的线程是伪线程？
答：在python的原始解释器CPython中存在着GIL（Global Interpreter Lock，全局解释器锁），因此在解释执行python代码时，会产生互斥锁来限制线程对共享资源的访问，直到解释器遇到I/O操作或者操作次数达到一定数目时才会释放GIL。
所以，虽然CPython的线程库直接封装了系统的原生线程，但CPython整体作为一个进程，同一时间只会有一个线程在跑，其他线程则处于等待状态。这就造成了即使在多核CPU中，多线程也只是做着分时切换而已。
参考自：https://www.zhihu.com/question/23474039
3、python的append和extend有什么区别？
答：extend()接受一个列表参数，把参数列表的元素添加到列表的尾部，append()接受一个对象参数，把对象添加到列表的尾部。
13、GIL锁是什么
线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。
解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能).
14、Python中如何使用进程池和线程池
进程池：就是在一个进程内控制一定个数的线程
基于concurent.future模块的进程池和线程池 （他们的同步执行和异步执行是一样的）
http://www.cnblogs.com/haiyan123/p/7461294.html
15、threading.local的作用
a. threading.local
作用：为每个线程开辟一块空间进行数据存储。
问题：自己通过字典创建一个类似于threading.local的东西。
    storage={
        4740:{val:0},
        4732:{val:1},
        4731:{val:3},
        ...
    }

b. 自定义Local对象
作用：为每个线程(协程)开辟一块空间进行数据存储。

    try:
        from greenlet import getcurrent as get_ident
    except Exception as e:
        from threading import get_ident
    
    from threading import Thread
    import time
    
    class Local(object):
    
        def __init__(self):
            object.__setattr__(self,'storage',{})
    
        def __setattr__(self, k, v):
            ident = get_ident()
            if ident in self.storage:
                self.storage[ident][k] = v
            else:
                self.storage[ident] = {k: v}
    
        def __getattr__(self, k):
            ident = get_ident()
            return self.storage[ident][k]
    
    obj = Local()
    
    def task(arg):
        obj.val = arg
        obj.xxx = arg
        print(obj.val)
    
    for i in range(10):
        t = Thread(target=task,args=(i,))
        t.start()

16、进程间如何进行通信
进程间通信主要包括管道, 系统IPC（包括消息队列,信号,共享存储), 套接字(SOCKET).
管道包括三种:
1)普通管道PIPE, 通常有两种限制,一是单工,只能单向传输;二是只能在父子或者兄弟进程间使用.
2)流管道s_pipe: 去除了第一种限制,为半双工，可以双向传输.
3)命名管道:name_pipe, 去除了第二种限制,可以在许多并不相关的进程之间进行通讯.
17、什么是并发和并行
如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统。并发系统与并行系统这两个定义之间的关键差异在于“存在”这个词。
在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。
我相信你已经能够得出结论——“并行”概念是“并发”概念的一个子集。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。
摘自：《并发的艺术》 — 〔美〕布雷谢斯
18、进程锁和线程锁的作用
线程锁:大家都不陌生，主要用来给方法、代码块加锁。当某个方法或者代码块使用锁时，那么在同一时刻至多仅有有一个线程在执行该段代码。当有多个线程访问同一对象的加锁方法/代码块时，同一时间只有一个线程在执行，其余线程必须要等待当前线程执行完之后才能执行该代码段。但是，其余线程是可以访问该对象中的非加锁代码块的。
进程锁:也是为了控制同一操作系统中多个进程访问一个共享资源，只是因为程序的独立性，各个进程是无法控制其他进程对资源的访问的，但是可以使用本地系统的信号量控制（操作系统基本知识）。
分布式锁:当多个进程不在同一个系统之中时，使用分布式锁控制多个进程对资源的访问。
http://www.cnblogs.com/intsmaze/p/6384105.html
19、解释什么是异步非阻塞
同步异步指的是在客户端
同步意味着客户端提出了一个请求以后，在回应之前只能等待
异步意味着 客户端提出一个请求以后，还可以继续提其他请求阻塞
非阻塞 指的是服务器端
阻塞意味着服务器接受一个请求后，在返回结果以前不能接受其他请求
非阻塞意味着服务器接受一个请求后，尽管没有返回结果，还是可以继续接受其他请求
20、路由器和交换机的区别
交换机工作于数据链路层，用来隔离冲突域，连接的所有设备同属于一个广播域（子网），负责子网内部通信。
路由器工作于网络层，用来隔离广播域（子网），连接的设备分属不同子网，工作范围是多个子网之间，负责网络与网络之间通信。
https://www.zhihu.com/question/20465477
21、什么是域名解析
域名解析是把域名指向网站空间IP，让人们通过注册的域名可以方便地访问到网站的一种服务。IP地址是网络上标识站点的数字地址，为了方便记忆，采用域名来代替IP地址标识站点地址。域名解析就是域名到IP地址的转换过程。域名的解析工作由DNS服务器完成。
22、如何修改本地hosts文件
1）hosts文件的位置：C:\windows\system32\drivers\etc，文件夹中找到Hosts文件并用记事本打开。
2）按照 ip地址  域名 的格式添加单独的一行记录。例如
112.124.39.29 www.server110.com
注意，IP地址前面不要有空格，ip地址和域名之间，要有至少1个空格。
修改后，一定要记得保存文件。
3）如何知道域名的IP地址已经生效？
在您的电脑上请按如下步骤操作：开始-->运行-->输入cmd-->ping 域名-->回车查看结果
显示结果类似 Reply from 220.181.31.183: bytes=32 time=79ms TTL=53
中间的  220.181.31.183 就是域名的IP地址

注意：有些浏览器会保存DNS缓存，比如Chrome。多按几次F5刷新即可。
https://www.cnblogs.com/cl-blogs/p/4160483.html


23、生产者和消费者模型以及应用场景
生产者消费者模型
在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。
为什么要使用生产者和消费者模式

在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。
什么是生产者消费者模式

生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。
http://www.cnblogs.com/huchong/p/7454756.html
24、什么是CDN
CDN主要功能是在不同的地点缓存内容，通过负载均衡技术，将用户的请求定向到最合适的缓存服务器上去获取内容，比如说，是北京的用户，我们让他访问北京的节点，深圳的用户，我们让他访问深圳的节点。通过就近访问，加速用户对网站的访问。解决Internet网络拥堵状况，提高用户访问网络的响应速度。
CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。
25、LVS是什么以及作用
LVS 是 Linux  Virtual Server ，Linux 虚拟服务器；是一个虚拟的服务器集群【多台机器 LB IP】。LVS 集群分为三层结构:

负载调度器(load balancer)：它是整个LVS 集群对外的前端机器，负责将client请求发送到一组服务器[多台LB IP]上执行，而client端认为是返回来一个同一个IP【通常把这个IP 称为虚拟IP/VIP】
服务器池(server pool)：一组真正执行client 请求的服务器，一般是我们的web服务器；除了web，还有FTP，MAIL，DNS
共享存储(shared stored)：它为 server pool 提供了一个共享的存储区，很容易让服务器池拥有相同的内容，提供相同的服务[不是很理解]

https://blog.csdn.net/caoshuming_500/article/details/8291940
26、Nginx是什么以及作用
Nginx是一个轻量级、高性能、稳定性高、并发性好的HTTP和反向代理服务器。
https://blog.csdn.net/b9x__/article/details/80400697
https://www.cnblogs.com/xiohao/p/6433401.html
27、keepalived是什么以及作用
https://baike.baidu.com/item/Keepalived/10346758?fr=aladdin
28、haproxy是什么以及作用
https://baike.baidu.com/item/haproxy/5825820
29、什么是负载均衡
负载均衡 建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。
负载均衡，英文名称为Load Balance，其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。
https://baike.baidu.com/item/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1
30、什么是RPC以及应用场景
RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。
RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。
31、简述asynio
https://www.cnblogs.com/zhaof/p/8490045.html
32、简述gevent模块作用及应用场景
https://www.cnblogs.com/zcqdream/p/6196040.html
33、twisted框架的使用和应用
ttp://www.cnblogs.com/zhiyong-ITNote/p/7360442.html

