---
title: Rust所有权
date: 2019-08-27 14:14:44
tags: rust 
ownership
---

所有权（系统）是 Rust 最独特的功能，其令 Rust 无需垃圾回收（garbage collector）即可保障内存安全。因此，理解 Rust 中所有权如何工作是十分重要的。本文中，我们将讲到所有权以及相关功能：借用、slice 以及 Rust 如何在内存中布局数据。

所有运行的程序都必须管理其使用计算机内存的方式。一些语言中具有垃圾回收机制，在程序运行时不断地寻找不再使用的内存；在另一些语言中，程序员必须亲自分配和释放内存。Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。在运行时，所有权系统的任何功能都不会减慢程序。

##栈Stack&堆Heap

栈：后进先出last in, first out

进栈
出栈

栈的操作是十分快速的，这主要是得益于它存取数据的方式：因为数据存取的位置总是在栈顶而不需要寻找一个位置存放或读取数据。另一个让操作栈快速的属性是，栈中的所有数据都必须占用已知且固定的大小。

堆：

在编译时大小未知或大小可能变化的数据，要改为存储在堆上。堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 指针（pointer）。这个过程称作 在堆上分配内存（allocating on the heap），有时简称为 “分配”（allocating）。将数据推入栈中并不被认为是分配。因为指针的大小是已知并且固定的，你可以将指针存储在栈上，不过当需要实际数据时，必须访问指针。

##所有权规则
1.Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。
2.值有且只有一个所有者。
3.当所有者（变量）离开作用域，这个值将被丢弃。

## 变量作用域

作用域是一个项（item）在程序中有效的范围。

let s = "hello"

变量s绑定到了一个字符串字面值，这个字符串值是硬编码进程序代码中的。这个变量从声明的点开始直到当前作用域结束时都是有效的。

{							 // s 在这里无效，它尚未声明

let s = "hello";  //从此处起，s是有效的

// 使用 s

}							// 此作用域已结束， s 不再有效

## String类型

我们已经见过字符串字面值，字符串值被硬编码进程序里。字符串字面值是很方便的，不过他们并不适合使用文本的每一种场景。原因之一就是他们是不可变的。另一个原因是并不是所有字符串的值都能在编写代码时就知道：例如，要是想获取用户输入并存储该怎么办呢？为此，Rust 有第二个字符串类型，String。这个类型被分配到堆上，所以能够存储在编译时未知大小的文本。可以使用 from 函数基于字符串字面值来创建 String，如下：

let s =String :: from("hello")

这两个冒号（ :: ）是运算符，允许将特定的 from 函数置于 String 类型的命名空间（namespace）下，而不需要使用类似 string_from 这样的名字。

修改：

let mut s = String::from("hello");

s.push_str(" , world! ");  // push_str() 在字符串后追加字面值

println!("{}", s);  // 将打印 `hello, world!`

### Q：为什么String可变而字面值却不行？区别在于两个类型对内存的处理

###内存与分配

字符串字面值：在编译时就知道其内容，所以文本被直接硬编码进最终的可执行文件中。

这使得字符串字面值快速且高效。不过这些特性都只得益于字符串字面值的不可变性。不幸的是，我们不能为了每一个在编译时大小未知的文本而将一块内存放入二进制文件中，并且它的大小还可能随着程序运行而改变。

对于 String 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。这意味着：

+ 必须在运行时向操作系统请求内存。
+ 需要一个当我们处理完 String 时将内存返回给操作系统的方法。

第一部分，当调用String :: from 时。在有 垃圾回收（garbage collector，GC）的语言中，GC记录并清除不再使用的内存。

正确处理内存回收曾经是一个困难的编程问题。

如果忘记回收了会浪费内存；

如果过早回收了，将会出现无效变量；

如果重复回收，这也是个bug；

我们需要精确地为一个allocate配对一个free。

Rust采用了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。

```rust
{
    let s = String :: from("hello"); // 从此处起，s 是有效的

	// 使用 s

}                                  // 此作用域已结束，
                                   // s 不再有效

```

这是一个将 String 需要的内存返回给操作系统的很自然的位置：当 s 离开作用域的时候。当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 drop，在这里 String 的作者可以放置释放内存的代码。Rust 在结尾的 } 处自动调用 drop。

<  注意：在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 资源获取即初始化（Resource Acquisition Is Initialization (RAII)）。如果你使用过 RAII 模式的话应该对 Rust 的 drop 函数并不陌生。

###变量与数据交互的方式(一)：移动

如果你在其他语言中听说过术语 浅拷贝（shallow copy）和 深拷贝（deep copy），那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。不过因为 Rust 同时使第一个变量无效了，这个操作被称为 移动（move），而不是浅拷贝。

###变量与数据交互的方式（二）：克隆

如果我们 确实 需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 clone 的通用函数。以下是一个克隆的例子：

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

###只在栈上的数据：拷贝
这里还有一个没有提到的小窍门。这些代码使用了整型并且是有效的，他们是示例 4-2 中的一部分：

```rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);

```


但这段代码似乎与我们刚刚学到的内容相矛盾：没有调用 clone，不过 x 依然有效且没有被移动到 y 中。

原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效。换句话说，这里没有深浅拷贝的区别，所以这里调用 clone 并不会与通常的浅拷贝有什么不同，我们可以不用管它。

Rust 有一个叫做 Copy trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上

如果一个类型拥有 Copy trait，一个旧的变量在将其赋值给其他变量后仍然可用。

Rust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。

如果我们对其值离开作用域时需要特殊处理的类型使用 Copy 注解，将会出现一个编译时错误。